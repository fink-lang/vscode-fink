{obj_values} = import '@fink/std-lib/obj'
{length, chain} = import '@fink/std-lib/iter'


walk_exprs = fn exprs, props:
  pipe exprs:
    map expr:
      ...walk expr, props


walk = fn expr, props={scope: {expr}}:
  node = {expr, ...props}
  parent = node

  chain
    [node]
    match expr:
      {type: 'module'}:
        walk_exprs expr.exprs, {parent, decl: false, scope: node}

      {type: 'block', op: 'match'}:
        chain
          walk_exprs expr.args, {parent, decl: false, scope: node.scope}
          walk_exprs expr.exprs, {parent, decl: false, scope: node}

      {type: 'block', op: 'pipe'}:
        chain
          walk_exprs expr.args, {parent, decl: false, scope: node.scope}
          walk_exprs expr.exprs, {parent, decl: false, scope: node}

      {type: 'block', args: []}:
        chain
          walk_exprs expr.args, {parent, decl: true, scope: node}
          walk_exprs expr.exprs, {parent, decl: false, scope: node}

      {type: 'block'}:
        walk_exprs expr.exprs, {parent, decl: false, scope: node}

      {type: 'call'}:
        chain
          walk expr.callee, {parent, decl: false, scope: node.scope}
          walk_exprs expr.args, {parent, decl: false, scope: node.scope}

      {type: 'object'}:
        walk_exprs expr.exprs, {parent, decl: props.decl, scope: node.scope}

      {type: 'object:prop', left: ? == expr.right}:
        chain
          walk expr.left, {parent, decl: props.decl, scope: node.scope}

      {type: 'object:prop'}:
        chain
          walk expr.left, {parent, decl: false, scope: node.scope}
          walk expr.right, {parent, decl: props.decl, scope: node.scope}

      {type: 'member'}:
        chain
          walk expr.left, {parent, decl: false, scope: node.scope}
          walk expr.right, {parent, decl: false, scope: node.scope}

      {type: 'assign'}:
        chain
          walk expr.left, {parent, decl: true, scope: node.scope}
          walk expr.right, {parent, decl: false, scope: node.scope}

      {type: 'string'}:
        walk_exprs expr.exprs, {parent, decl: false, scope: node.scope}

      {type: 'array'}:
        walk_exprs expr.exprs, {parent, decl: props.decl, scope: node.scope}

      {type: 'group'}:
        walk_exprs expr.exprs, {parent, decl: props.decl, scope: node.scope}

      {left: {}, right: {}}:
        chain
          walk expr.left, {parent, decl: false, scope: node.scope}
          walk expr.right, {parent, decl: false, scope: node.scope}

      {right: {}}:
        walk expr.right, {parent, decl: props.decl, scope: node.scope}

      {op: 'try'}:
        walk_exprs expr.exprs, {parent, decl: false, scope: node.scope}

      {type: 'jsx-elem'}:
        chain
          walk_exprs expr.props, {parent, decl: false, scope: node.scope}
          walk_exprs expr.children, {parent, decl: false, scope: node.scope}

      {type: 'jsx-attr', value: {}}:
        walk expr.value, {parent, decl: false, scope: node.scope}

      {type: 'jsx-expr-container'}:
        walk expr.expr, {parent, decl: false, scope: node.scope}

      else:
        []


insert_to_prop = fn obj, key, item:
  {(key): items=[]} = obj
  {...obj, (key): [item, ...items]}


expr_id = fn {loc: {start, end}}:
  `${start.pos}:${end.pos}`


ident_id = fn {value}:
  `id:${value}`


is_var = fn node:
  {expr} = node
  match node:
    {
      expr: {type: 'ident'}
      parent: {expr: {type: 'member', right: expr}}
    }:
      false
    {
      expr: {type: 'ident'}
      parent: {expr: {type: 'object:prop', left: expr, right: ? != expr}}
    }:
      false
    {expr: {type: 'ident'}}:
      true
    else:
      false


is_at_loc = fn expr, loc:
  {line, column} = loc
  match expr.loc:
    {
      start: {line, column: ? <= column},
      end: {line, column: ? >= column}
    }:
      true
    else:
      false


get_exprs_from_loc = fn ast, pos:
  pipe walk ast:
    while {expr}:
      match expr:
        {loc: {start: {line: ? <= pos.line}}}: true
        else: false

    filter {expr}:
      match expr:
        {type: 'ident'}: true
        {type: 'number'}: true
        {type: 'string:text'}: true
        else: false

    filter {expr}:
      match expr.loc:
        {
          start: {line: ? <= pos.line, column: ? <= pos.column},
          end: {line: ? >= pos.line, column: ? >= pos.column}
        }: true
        else: false


is_declaring = fn node:
  match node:
    {decl: true}: true
    else: false


get_idents = fn ast:
  [...idents] = pipe walk ast:
    filter node: is_var node
  idents


find_decls = fn ident, scope, scopes:
  scope_id = expr_id scope.expr
  decls_by_id = scopes.(scope_id) || []
  decls = decls_by_id.(ident_id ident) || []

  match scope:
    {parent: {}}:
      parent_scope_decls = find_decls ident, scope.parent, scopes
      [...decls, ...parent_scope_decls]
    else:
      decls


get_decls = fn node, scopes:
  find_decls node.expr, node.scope, scopes


get_refs_for_decl = fn refs, decl:
  decl_id = expr_id decl.expr
  pipe refs:
    filter ref:
      ref_id = expr_id ref.decl.expr
      decl_id == ref_id


get_refs = fn idents, scopes:
  init_refs = pipe idents:
    filter {decl}: decl
    fold decl, refs={}:
      decl_id = expr_id decl.expr
      {...refs, (decl_id): {decl, idents: []}}

  pipe idents:
    fold node, refs=init_refs:
      decls = get_decls node, scopes

      match decls:
        0 == length ?:
          refs
        else:
          [decl] = decls
          decl_id = expr_id decl.expr
          ref = refs.(decl_id)

          {...refs, (decl_id): {...ref, idents: [...ref.idents, node]}}

    fn refs: obj_values refs


decls_by_scope = fn idents:
  pipe idents:
    filter node: is_declaring node

    fold decl, scopes={}:
      scope_id = expr_id decl.scope.expr
      decl_id = ident_id decl.expr

      {(scope_id): decls={}} = scopes
      new_decls = insert_to_prop decls, decl_id, decl

      {...scopes, (scope_id): new_decls}


