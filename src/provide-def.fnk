{languages, Uri, Location, workspace} = import 'vscode'

{decode} = import '@fink/std-lib/str.fnk'
{new, set_props} = import '@fink/js-interop/reflect.fnk'

{to_larix_pos, doc_range, range} = import './loc.fnk'

{walk} = import '@fink/larix/ast/traverse.fnk'
{get_parent, find_binding, add_parents, add_binding_refs} = import '@fink/larix/ast/analyze.fnk'
{ref_loc, is_imported, get_import} = import './common.fnk'



resolve = fn doc, path:
  uris = seq:
    Uri.joinPath doc.uri, '..', '${path}'
    Uri.joinPath doc.uri, '..', '${path}.fnk'
    Uri.joinPath doc.uri, '..', '${path}/index.fnk'

  [await uri] = pipe uris:
    filter await uri:
      [, stat] = try:
        await workspace.fs.stat uri

      match stat:
        {type: 1}: true
        else: false
  uri



import_link = fn doc, import_expr:
  {right: {exprs: [path]}} = import_expr
  origin_range = range path.loc

  target = await resolve doc, path.value

  target_range = range {start: {line: 1, column: 1}, end: {line: 1, column: 1}}

  link = new Location, target, target_range

  set_props link, {originSelectionRange: origin_range}
  link



fake_doc = fn uri:
  rec:
    uri
    version: '0'
    getText: fn:
      data = await workspace.fs.readFile uri
      decode data, 'utf-8'



imported_decl = fn async_parse, doc, expr, ctx:
  {right: imp_uri_str} = get_import expr, ctx
  {exprs: [{value: imp_spec}]} = imp_uri_str

  {left: {value: exported_name}} = get_parent expr, ctx

  uri = await resolve doc, imp_spec
  ast = await async_parse fake_doc uri

  [loc] = pipe ast.exprs:
    filter expr:
      match expr:
        {left: {type: 'ident', value: exported_name}, op: '='}:
          true
        else:
          false
    map {left}:
      doc_range {uri}, ref_loc left
  loc



is_at_loc = fn expr, loc:
  {line, column} = loc
  match ref_loc expr:
    {
      start: {line: ? <= line, column: ? <= column},
      end: {line: ? >= line, column: ? >= column}
    }:
      true
    else:
      false


keep_refs_at = fn pos:
  filter [expr]:
    match expr:
      {type: 'ident'}: is_at_loc expr, pos
      {type: 'jsx:elem'}: is_at_loc expr, pos
      {type: 'jsx:attr'}: is_at_loc expr, pos
      {op: 'import'}: is_at_loc expr, pos
      else: false



as_bindings = map [expr], , ctx:
  ... match expr:
    {op: 'import'}:
      [[expr], , ctx]
    else:
      binding = find_binding expr, ctx
      match binding:
        false:
          [[], , ctx]
        else:
          [[binding], , ctx]



as_doc_locs = fn doc, async_parse:
  map await expr, , ctx:
    loc = match expr:
      {op: 'import'}:
        await import_link doc, expr

      is_imported ?, ctx:
        await imported_decl async_parse, doc, expr, ctx

      else:
        doc_range doc, ref_loc expr

    ... match loc:
      {}: [[loc], , ctx]
      else: [[], , ctx]



def_provider = fn async_parse: fn doc, vspos:
  ast = await async_parse doc
  pos = to_larix_pos vspos

  [locs] = await pipe ast:
    walk [?]
    add_parents
    add_binding_refs
    keep_refs_at pos
    as_bindings
    as_doc_locs doc, async_parse

    # TODO: use std-lib async parallel or sequential
    fold await link, out=[], , ctx={}:
      [[...out, link], , ctx]

  locs



add_definition_provider = fn {subscriptions}, async_parse:

  subscr = languages.registerDefinitionProvider
    'fink'
    {provideDefinition: def_provider async_parse}

  subscriptions.push subscr

